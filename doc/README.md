sqd at dragonazd@gmail.com

Or while you hear that PRC's blocked gmail:757887477@qq.com

#Caskell
##A haskell-style functional programming library for C++

#1.The header file to include

    generator.cpp(TODO:improve the including structure)
    
#2.Functions

	Should not directly define the class templates started with "g" or "f" (So far), unless you are intended to extend this library. So ese the functions listed below.
    
	TODO:by improving the including structure, hide the "g" and "f" templates
    
	The functions provided in section I) and section II) (in which functions are all inherited from `class generator`) will have following universial interfaces:
		1)`operator *` and `operator ->`
			Access the element (by const reference or pointer) the generator is "pointing" to.
		2)`operator ++` (both suffix and prefix) and `void skip()`
			Abandon current element and jump to next element
		3)`bool is_end()`
			For finite generator, indicates whether the last element has been generated. For infinite generator, this function always returns false
		4)`clend end` and `bool operator ==(const clend &_)`
			Same as `is_end()`, in fact, internally it's implemented by is_end(). With this you can write more C++-style code such as `for(auto g=create_a_generator();g!=g::end();++g)` 
		5)`void conv2container(start,end)`
			Call this function with two STL iterator or pointer, it will fill the memory indicated by them. 
			CAUTION: Do no check on validity of the range provided.

	Functions provided:
##	I)Actual generator
		The functions(or functors, technically speaking) in this section directly generate elements in certain pattern.

		iter(T data,F func)
			Infinite
			Iteratively call the given function `func` with the given element `data` and restore the result in it for next calling. Base of some other functions.
			Example:
				`iter(1,inc<int>())` will return a generator generate 1,2,3....
		
		range(T begin,T end,F func=inc<T>(),cmpF cmpf=not_more_than<T>())
			(Possible) finite
			Iteratively call `func` until the result reach `end`
			Similiar to `for(;cmpf(begin,end);func(begin))`
			Example:
				`range(1000,1,dec<int>())` will return a generator with 1000,999...2,1
		
		increment(T data)
			Infinite, based on `iter`
			Example:
				`incement(555)` returns 555,556,557...
		
		decrement(T data)
			Infinite, based on `iter`
		
		repeat(T data)
			Infinite, based on `iter`
			Infinitely repeat `data`
			Example:
				`repeat("boring to write readme")` returns `"boring to write readme","boring to write readme","boring to write readme"...`

##	II)Embellish generator
		The funtions here embellish output of other generators

		circle(T gen)
			Infinite
			Circlely generator elements generated by `gen`
			Example:
				`circle(range(1,3))` returns 1,2,3,1,2,3,1...
		
		concat(T1 gen1,T2 gen2)
			(Possible) finite
			Concat the elments from `gen1` and `gen2`
			Example:
				`concat(range(1,3),repeat(4))` returns 1,2,3,4,4,4,4,4...
				`concat(range(1,3),range(3,1,dec<int>()))` returns 1,2,3,3,2,1

		take(int size,T gen)
			Finite
			Take only first `size` elements of `gen`
			Example:
				`take(5,iter(1,inc<int>()))` returns 1,2,3,4,5

		mapf(T gen,F func)
			(Possible) finite
			Call the `func` with the element generated by `gen` and return a generator generates those return values.
			PS:suffix "f" is to avoid conflict with std::map
			Example:
				`mapf(repeat(true),logic_not)` returns false,false,false...

		filter(T gen,F func)
			(Possible) finite
			Returns a generator in which all elements are generated from `gen` and fufill the constraint of `func`
			Example:
				TODO:Add more metafunc to have a example

		fold(ReturnVal first,T gen,F func)
			(Possible) finite
			Iteratively call `func` with `first` and current element in `gen`; restore the result in `first` for next call and return the result.
			Example:
				fold(0,range(1,100),add<int>()) calculates the sum of 1,2...100

		wrapSTL(T container)
			Finite CAUTION: EXPERIMENTAL FUNCTION, MAY BE CANCELLED LATER
			Wrap a STL container into a generator
			Example:
				`vector<int> v={1,2,3,4};auto g=wrapSTL(v)`
				In which `g` returns 1,2,3,4
##	III)Meta function
		A set of pre-defined tiny but practical functions to be paramenter of generators

		curry(T fix_arg,F func)
			Returns a callable object with a fix parameter `fix_arg` in function `func`
			Example:
				`map(increment(1),curry(2,multi<int>()))` returns `2,4,6...`

		first(T gen),last(T gen)
			Returns the first/last element of `gen`
			Example:
				`last(range(1,555))` is `555`

		inc<T>,dec<T>
			Returns a callable object performs `++`/`--` operator
			Example:
				`inc<int>(999)` is `1000`

		reflect<T>
			Returns the same parameter that was passed in.
			Example:
				`reflect<int>(999)` is `999`

		n_repeat(int n,T first,T alternative)
			CAUTION: MAY BE REPLACED BY OTHER MORE GENERAL FUNCTION
			TODO:write a n_n_switch function to replace this
			Repeat `first` `n` times, then keep answering `alternative`
			Example:
				`n_repeat(3,1,2)` is `1,1,1,2,2,2,2,2...`

		n_true(int n)/n_false(int n)
			Repeat true/false `n` times, then switch to another

		flip(F func)
			Swap the order of parameters of a binary parameters function.
			Example:
				`flip(div<int>())(100,1000)` is `100` while `div<int>()(1000,100)` is also `100`

		notf(F func)
			Perform `operator !` on the output of `func`
			Overloaded to accept both single and binary parameter functions.
			Example:
				`notf(equal<T>())` is the identical to `not_equal<T>`

		Other dull functions:(not_)equal,equal,logic_(and/or/not/xor),add/minus/multi/div/mod,(not)less_than..blah.

##	IV)Other
		executor(T gen,F func)
			Returns a object with following functions:
				`void exe()` and `operator *`:call `func` with current element. Neglect the return value.
				`operator ++` and `skip()`: same as section I
		Example:
			`void print(int i){cout<<i<<' ';}
			auto e=executor(range(1,3),print);
			e.exe();
			*e;
			++e;
			*e;`
			Output:
			1 1 2

		gen_print(T gen,Tsep sep="",ostream& s=cout)
			Print elements in `gen`, seperated with `sep`, into stream `s`
			CAUTION: may fall in death loop with infinite `gen`
			Example:
				`gen_print(range(1,3),"-")`
				Output:
				1-2-3

		all(T gen,func=refect<bool>())
			Indicate whether all/any elements in `gen` fulfill the contraint of `func`


#3.How to extend this library

!TODO:
Contemplate about "no side effect"
!General
	Improve function combination

!The functions to be added in
	dump2container
	inter(calate/sperse)
	search_in
	poly
!The functions to be improved

	concat: allow multi parameter by parameter pack
	curry: dito
	n_n_switch: dito
	zip: dito

	slice:use a queue to make it not neccesary to generate the whole list in some cases

!The function to be deleted
